import React, { useState, useRef, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import './App.css';

// --- ICONS ---
const SendIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>;
const SparkleIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="url(#brand-grad)"><defs><linearGradient id="brand-grad" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stopColor="#1b3544" /><stop offset="100%" stopColor="#6EB487" /></linearGradient></defs><path d="M12 22c4.97 0 9-4.03 9-9-4.97 0-9-4.03-9-9-4.97 0-9 4.03-9 9 0 4.97 4.03 9 9 9zm0-2c-3.87 0-7-3.13-7-7 0-3.87 3.13-7 7-7 3.87 0 7 3.13 7 7 0 3.87-3.13 7-7 7z"/></svg>;
const UserIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>;

function App() {
  const { keyword } = useParams();
  const navigate = useNavigate();

  // DEBUG: Check if env var is loaded
  // console.log("VITE_GEMINI_KEY:", import.meta.env.VITE_GEMINI_KEY);
  // console.log("All env vars:", import.meta.env);

  const GEMINI_API_KEY = import.meta.env.VITE_GEMINI_KEY;
  const GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}`;

  const [topic, setTopic] = useState("");
  const [messages, setMessages] = useState([]);
  const [loading, setLoading] = useState(false);
  const [view, setView] = useState("chat");
  const [finalBlog, setFinalBlog] = useState("");

  const textareaRef = useRef(null);
  const chatEndRef = useRef(null);
  const hasAutoGenerated = useRef(false);

  useEffect(() => {
    if (keyword && !hasAutoGenerated.current) {
      hasAutoGenerated.current = true;
      handleSend(keyword);
    }
  }, [keyword]);

  useEffect(() => {
    chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const handleInput = (e) => {
    setTopic(e.target.value);
    e.target.style.height = 'auto';
    e.target.style.height = `${e.target.scrollHeight}px`;
  };

  const handlePublish = (htmlContent) => {
    setFinalBlog(htmlContent);
    setView("published");
  };

  // Fetch image from Lorem Picsum (free, no auth needed)
  const fetchPlaceholderImage = async (query) => {
    try {
      // Generate a random image based on keyword hash
      const hash = query.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
      const imageId = Math.abs(hash % 1000);
      const imageUrl = `https://picsum.photos/800/500?random=${imageId}`;
      return imageUrl;
    } catch (err) {
      console.error(`Image generation failed for "${query}":`, err);
      throw err;
    }
  };

  // Generate image using Replicate API (AI-generated, high quality)
  const generateImageWithAI = async (prompt) => {
    // Try backend first, then fallback to Pollinations (no API key) or Picsum
    try {
      const response = await fetch("http://localhost:3000/api/generate-image", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ prompt }),
      });

      if (response.ok) {
        const data = await response.json();
        if (data?.imageUrl) return data.imageUrl;
        console.warn("Backend returned no imageUrl, falling back:", data);
      } else {
        // Log backend error but do not throw — use fallback
        const bodyText = await response.text().catch(() => '');
        console.warn("Backend image endpoint error:", response.status, bodyText);
      }
    } catch (err) {
      console.warn("Error contacting backend image endpoint:", err?.message || err);
    }

    // Primary fallback: Pollinations AI image (no key) — better for diagram/infographic prompts
    try {
      const pollinations = `https://image.pollinations.ai/prompt/${encodeURIComponent(prompt)}?width=800&height=450&nologo=true`;
      return pollinations;
    } catch (err) {
      console.warn("Pollinations build failed:", err);
    }

    // Final fallback: Picsum random photo
    try {
      const hash = prompt.split('').reduce((acc, c) => acc + c.charCodeAt(0), 0);
      const id = Math.abs(hash % 1000);
      return `https://picsum.photos/800/500?random=${id}`;
    } catch (err) {
      console.warn("Picsum fallback failed:", err);
      return `https://placehold.co/800x500?text=${encodeURIComponent(prompt)}`;
    }
  };

  const handleSend = async (overrideTopic = null) => {
    const topicToUse = overrideTopic || topic;
    if (!topicToUse.trim()) return;

    if (!overrideTopic) {
        navigate(`/${topicToUse.replace(/\s+/g, '-')}`);
    }

    setTopic("");
    if(textareaRef.current) textareaRef.current.style.height = 'auto';

    setMessages(prev => [...prev, { role: 'user', content: topicToUse.replace(/-/g, ' ') }]);
    setLoading(true);
    setMessages(prev => [...prev, { role: 'ai', content: '', isLoading: true }]);

    const systemInstruction = `You are an expert technical blog writer.
    Write a detailed, 1000-word blog post about the user's topic in raw HTML format ONLY.

    MANDATORY Structure:
    1. <h1>A Catchy Title</h1>
    2. <p>An engaging Introduction paragraph</p>
    3. <h2>First Topic Heading</h2>
    4. <p>Body paragraph content here</p>
    5. <img-placeholder-RELEVANT_KEYWORD></img-placeholder>
    6. <h2>Second Topic Heading</h2>
    7. <p>Body paragraph content here</p>
    8. <img-placeholder-RELEVANT_KEYWORD></img-placeholder>
    9. <h2>Third Topic Heading</h2>
    10. <p>Body paragraph content here</p>
    11. <img-placeholder-RELEVANT_KEYWORD></img-placeholder>
    12. <h2>Fourth Topic Heading</h2>
    13. <p>Body paragraph content here</p>
    14. <img-placeholder-RELEVANT_KEYWORD></img-placeholder>
    15. <h2>Conclusion</h2>
    16. <p>Conclusion paragraph</p>
    17. <img-placeholder-RELEVANT_KEYWORD></img-placeholder>

    CRITICAL RULES:
    - You MUST include exactly 5 image placeholders in this format: <img-placeholder-KEYWORD></img-placeholder>
    - Replace KEYWORD with a relevant search term (e.g., cloud computing, machine learning, web development)
    - Each image placeholder MUST be on its own line by itself
    - Output ONLY raw HTML - no markdown, no backticks, no explanations
    - Do NOT wrap anything in code blocks`;

    try {
      const response = await fetch(GEMINI_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          systemInstruction: {
            parts: [{
              text: systemInstruction
            }]
          },
          contents: [{
            role: "user",
            parts: [{ text: topicToUse }]
          }]
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error("Gemini API Error: " + (errorData.error?.message || response.statusText));
      }

      const result = await response.json();
      let aiText = result.candidates[0].content.parts[0].text;

      console.log("Raw Gemini response:", aiText); // DEBUG

      // Clean up any accidental markdown wrappers
      aiText = aiText.replace(/```html/g, '').replace(/```/g, '');

      // Extract image placeholders - use more flexible regex
      const placeholders = aiText.match(/<img-placeholder-([^<>]+)><\/img-placeholder[^>]*>/g) || [];
      console.log("Found placeholders:", placeholders); // DEBUG

      let processedContent = aiText;

      for (const placeholder of placeholders) {
        const keywordMatch = placeholder.match(/<img-placeholder-([^<>]+)><\/img-placeholder/);
        if (!keywordMatch) continue;
        
        const keyword = keywordMatch[1].trim();
        console.log(`Generating image for: ${keyword}`); // DEBUG
        
        try {
          const imageUrl = await generateImageWithAI(keyword);
          const imgTag = `<figure style="margin: 20px 0; text-align: center;">
            <img src="${imageUrl}" alt="${keyword}" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
          </figure>`;
          processedContent = processedContent.replace(placeholder, imgTag);
          console.log(`Image generated for: ${keyword}`); // DEBUG
        } catch (err) {
          console.error(`Failed to generate image for ${keyword}:`, err);
          processedContent = processedContent.replace(placeholder, '');
        }
      }

      setMessages(prev => {
        const newMsgs = [...prev];
        newMsgs[newMsgs.length - 1] = { role: 'ai', content: processedContent, isLoading: false };
        return newMsgs;
      });

    } catch (err) {
      console.error(err);
      setMessages(prev => {
        const newMsgs = [...prev];
        newMsgs[newMsgs.length - 1] = { role: 'ai', content: "Error connecting to Gemini API. Check your API Key.", isLoading: false, isError: true };
        return newMsgs;
      });
    } finally {
      setLoading(false);
    }
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  if (view === 'published') {
    return (
      <div className="blog-page-container fade-in">
        <nav className="blog-nav">
          <button className="nav-btn" onClick={() => setView('chat')}>
            ← Back to Editor
          </button>
          <div className="brand-logo" style={{color:'#e3e3e3'}}>
            LIVE<span style={{color:'#6EB487'}}>PREVIEW</span>
          </div>
        </nav>
        <article className="blog-article">
          <div dangerouslySetInnerHTML={{ __html: finalBlog }} />
        </article>
      </div>
    );
  }

  return (
    <div className="app-layout">
      <main className="main-content">
        <div className="top-bar">
          <div className="brand-logo">BLOGGER<span style={{color: '#6EB487'}}>.AI</span></div>
          <div className="user-profile"><div className="avatar-circle"></div></div>
        </div>

        {messages.length === 0 ? (
          <div className="welcome-container">
            <div className="greet-text">
              <span className="gradient-text">Hello!</span>
              <span style={{color: '#85c6b6ff'}}>Enter a URL keyword or type below.</span>
            </div>
          </div>
        ) : (
          <div className="chat-feed">
            {messages.map((msg, idx) => (
              <div key={idx} className={`message-wrapper ${msg.role}`}>
                {msg.role === 'user' && (
                  <div className="user-message">
                    <div className="msg-text">{msg.content}</div>
                    <div className="user-icon"><UserIcon /></div>
                  </div>
                )}
                {msg.role === 'ai' && (
                  <div className="ai-message-group">
                    <div className="ai-icon"><SparkleIcon /></div>
                    {msg.isLoading ? (
                      <div className="loading-bubble">
                        <div className="gemini-loader"></div>
                        <span>Agent is writing about "{keyword || topic}"...</span>
                      </div>
                    ) : (
                      <div className="blog-card fade-in">
                        <div className="blog-card-header"><span className="badge">GENERATED POST</span></div>
                        <div className="blog-content" dangerouslySetInnerHTML={{ __html: msg.content }} />
                        <div className="blog-card-footer">
                           <button className="card-action primary" onClick={() => handlePublish(msg.content)}>Publish</button>
                        </div>
                      </div>
                    )}
                  </div>
                )}
              </div>
            ))}
            <div ref={chatEndRef} />
          </div>
        )}

        <div className="input-area">
          <div className="input-container">
            <textarea
              ref={textareaRef}
              placeholder="Enter a topic..."
              rows={1}
              value={topic}
              onChange={handleInput}
              onKeyDown={handleKeyDown}
            />
            <button className={`submit-btn ${topic.trim() ? 'has-text' : ''}`} onClick={() => handleSend()}>
              <SendIcon />
            </button>
          </div>
        </div>
      </main>
    </div>
  );
}

export default App;